"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateInlineMap = generateInlineMap;
exports.isAbsolute = isAbsolute;
exports.normalizePath = normalizePath;
exports.relatifyPath = relatifyPath;
exports.partialVlqMapToSourceMap = partialVlqMapToSourceMap;

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// For some reason path.isAbsolute barely works... Regex to the rescue?
// Apparently windows stuff is under `path.win32`, so yeah windows makes stuff complicated :)
const ABSOLUTE_PATH_REGEX = /^([a-zA-Z]:){0,1}[\\/]+/;
const PATH_SEPARATOR_REGEX = /\\/g;

function generateInlineMap(map) {
  return `data:application/json;charset=utf-8;base64,${Buffer.from(map).toString('base64')}`;
}

function isAbsolute(filepath) {
  return ABSOLUTE_PATH_REGEX.test(filepath);
}

function normalizePath(filepath) {
  if (process.platform === 'win32') {
    return filepath.replace(ABSOLUTE_PATH_REGEX, '/').replace(PATH_SEPARATOR_REGEX, '/');
  }

  return filepath;
}

function relatifyPath(filepath, rootDir) {
  rootDir = normalizePath(rootDir);
  filepath = normalizePath(filepath); // Make root paths relative to the rootDir

  if (filepath[0] === '/') {
    filepath = _path.default.relative(rootDir, filepath);
  } // Prefix relative paths with ./ as it makes it more clear and probably prevents issues


  if (filepath[0] !== '.') {
    filepath = `./${filepath}`;
  } // Sourcemaps are made for web, so replace backslashes with regular slashes


  return normalizePath(filepath);
}

async function partialVlqMapToSourceMap(map, {
  fs,
  file,
  sourceRoot,
  inlineSources,
  rootDir,
  format = 'string'
}) {
  let resultMap = { ...map,
    sourcesContent: map.sourcesContent ? map.sourcesContent.map(content => content ? content : null) : [],
    version: 3,
    file,
    sourceRoot
  };

  if (resultMap.sourcesContent.length < resultMap.sources.length) {
    resultMap.sourcesContent.push(...new Array(resultMap.sources.length - resultMap.sourcesContent.length).fill(null));
  }

  if (fs) {
    resultMap.sourcesContent = await Promise.all(resultMap.sourcesContent.map(async (content, index) => {
      let sourceName = map.sources[index]; // If sourceName starts with `..` it is outside rootDir, in this case we likely cannot access this file from the browser or packaged node_module
      // Because of this we have to include the sourceContent to ensure you can always see the sourcecontent for each mapping.

      if (!content && (inlineSources || sourceName.startsWith('..'))) {
        try {
          return await fs.readFile(_path.default.resolve(rootDir || '/', sourceName), 'utf-8');
        } catch (e) {}
      }

      return content;
    }));
  }

  if (format === 'inline' || format === 'string') {
    let stringifiedMap = JSON.stringify(resultMap);

    if (format === 'inline') {
      return generateInlineMap(stringifiedMap);
    }

    return stringifiedMap;
  }

  return resultMap;
}